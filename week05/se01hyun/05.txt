## 상속과 인터페이스

다중 상속을 포기하고 대신 인터페이스를 도입한 자바에서 인터페이스는 어떤 관계를 나타내는 것일까 다중 상속 대신이니 상속과 같이 is a kind of일까

- 상속 관계 하위 클래스 is a kind of 상위 클래스
- 해석 하위 클래스는 상위 클래스의 한 분류
- 예제 고래는 동물의 한 분류다.
- 인터페이스 구현 클래스 is able to 인터페이스
- 해석 구현 클래스는 인터페이스할 수 있다.
- 예제 고래는 헤엄칠 수 있다.

인터페이스는 be able to, 즉 “무엇을 할 수 있는”이라는 표현 형태로 만드는 것이 좋다.

- Serializable 인터페이스 직렬화할 수 있는
- Cloneable 인터페이스 복제할 수 있는
- Comparable 인터페이스 비교할 수 있는
- Runnable 인터페이스 실행할 수 있는

상위 클래스는 하위 클래스에게 특성(속성과 메서드)을 상속,

인터페이스는 클래스가 ‘무엇을 할 수 있다’라고 하는 긴능을 구현하도록 강제.

- 상위 클래스는 하위 클래스에게 물려줄 특성이 많을수록 좋을까 적을수록 좋을까
    - 상위 클래스는 물려줄 특성이 풍성할수록 👍
- 인터페이스는 구현을 강제할 메서드가 많을수록 좋을까 적을수록 좋을까
    - 인터페이스는 구현을 강제할 메서드의 개수가 적을수록 👍

## 상속과 UML 표기법

1. 두 클래스 간의 상속을 표현하기 위해 하위 클래스에서 상위 클래스 방향으로 화살표를 그린다. 화살표는 속이 비어있고 닫힌 삼각형 머리에 실선 꼬리를 가진 형태로 그린다.
2. 클래스가 인터페이스를 구현한 경우, 인터페이스를 구현하는 클래스에서 인터페이스 방향으로 화살표를 그린다. 이때 화살표는 꼬리가 점선인 점만 제외하고 상속 화살표와 모든 것이 같다. 인터페이스 구현에 대한 약식 표기로 막대 사탕을 사용하기도 한다.

## 상속과 T 메모리

(예제 참고)

Penguin 클래스의 인스턴스만 힙 영역에 생긴 게 아니라 Animal 클래스의 인스턴스도 함께 힙 영역에 생긴 것을 볼 수 있다. 또, 하위 클래스의 인스턴스가 생성될 때 상위 클래스의 인스턴스도 함께 생성된다. 사실 Animal 인스턴스 외에도 하나의 객체가 더 생성된다. 모든 클래스의 최상위 클래스인 Object 클래스의 인스턴스도 함께 생성되는 것이다.

## 다형성 사용편의성

### 오버라이딩 오버로딩

- 같은 메서드 이름, 같은 인자 목록으로 상위 클래스의 메서드를 재정의
- 같은 메서드 이름, 다른 인자 목록으로 다수의 메서드를 중복 정의
- ride 올라타다
- load 적재하다

## 다형성이 지원되지 않는 언어

- 다형성에 대해 사용 편의성이라고 정의한 이유
    - 오버로딩은 함수명 하나를 가지고 인자 목록만 달리하면 된다. 제네릭을 이용하면 하나의 함수만 구현해도 다수의 함수를 구현한 효과를 낼 수 있다.
- 오버라이딩의 경우, 하위 클래스가 재정의한 메서드를 알아서 호출해 줌으로써 형변환이나 instanceof 연산자를 써서 하위 클래스가 무엇인지 신경 쓰지 않아도 된다. 상위 클래스 타입의 객체 참조 변수에서 하위 클래스가 오버라이딩한 메서드를 자동으로 호출해 줌으로써 깔끔한 코드 유지!
- 오버라이딩을 통한 메서드 재정의, 오버로딩을 통한 메서드 중복정의를 통해 다형성을 제공하고 이 다형성이 개발자가 프로그램을 작성할 때 사용 편의성을 준다.

## 캡슐화 정보 은닉

자바에서 정보 은닉(information hiding)

- 접근 제어자인 private, [default], protected, public
- 접근자 및 설정자 메서드

## 객체 멤버의 접근 제어자

ClassA의 객체 멤버인 pri, def, pro, pub 속성이 보인다. UML 표기법에서 - 표시는 private 접근 제어자를, ~ 표시는 [default] 접근 제어자를, # 표시는 protected 접근 제어자를, + 표시는 public 접근 제어자를 나타낸다. 속성이나 메서드 아래에 _(밑줄)을 사용한 경우는 정적 멤버를 나타낸다.

```jsx
public class ClassA {
  private int pril;
  int def;
  protected int pro;
  public int pub;
  
  void runSomething() {
    
  }

  static void runStaticThing() {
    
  }
}
```

protected 가 자신과 상속 관계에 있는 서브 클래스만 접근 가능한 걸로 착각하는 경우가 많은데, 같은 패키지라면 한 집에 산다고 생각하기에 접근 가능하다는 사실도 꼭 기억해야 한다. 습관적으로 private 아니면 public만 사용하거나, 그냥 아무 표시도 하지 않는 [default]만 사용해 왔다면 반성이 필요한 대목이다.

- 상속을 받지 않았다면 객체 멤버는 객체를 생성한 후 객체 참조 변수를 이용해 접근해야 한다.
- 정적 멤버는 클래스명.정적멤버 형식으로 접근하는 것을 권장한다.

## 참조 변수의 복사

Call By Value와 Call By Reference를 다르다고 이해하기보다는 기본 자료형 변수는 저장하고 있는 값을 그 값 자체로 판단하고, 참조 변수는 저장하고 있는 값을 주소로 판단한다고 이해하는 것이 더 쉽다.

변수를 메서드의 인자나 반환값으로 사용하는 경우도 동일!

- 기본 자료형 변수는 값을 값 자체로 판단
- 참조 자료형 변수는 값을 주소, 즉 포인터로 판단
- 기본 자료형 변수를 복사할 때, 참조 자료형 변수를 복사할 때 일어나는 일은 같다.
즉, 가지고 있는 값을 그대로 복사해서 넘겨준다.

## 자바 키워드와 OOP 4대 특성

![image.png](attachment0c84579e-7a09-4035-8e89-e58f189db991image.png)