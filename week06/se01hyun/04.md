## abstract 키워드 - 추상 메서드와 추상 클래스
- **추상 메서드 (Abstract Method)** - 선언부만 있고 구현부가 없는 메서드
- **추상 클래스** - 추상 메서드를 하나라도 포함하면 반드시 추상 클래스로 선언해야 하며, 객체 생성 불가 (new 사용 불가)
- 하위 클래스가 추상 메서드를 오버라이딩하지 않으면 컴파일 에러 발생
> 추상 메서드는 하위 클래스에 구현을 강제한다..
## 생성자
- 클래스명과 동일한 이름의 메서드
- 반환값이 없으며 객체 생성에 사용
- *기본 생성자*는 생성자가 없을 때 자바가 자동 생성해 준다.
- *사용자 정의 생성자*가 하나라도 있으면 기본 생성자는 자동 생성 ❌
## 클래스 생성 시의 실행 블록, static 블록
- 자바에는 클래스 생성자는 없지만, **클래스가 처음 사용될 때 실행되는 static 블록**은 존재
- static 블록은 단 한 번만 실행되며, 클래스가 *처음 사용*될 때 실행
	- 클래스의 정적 속성 사용
	- 클래스의 정적 메서드 호출
	- 클래스 인스턴스 최초 생성
> static 영역은 메모리를 아끼기 위해 가능한 늦게 로딩되며, 한 번 로딩되면 해제되지 않는다.
## final 키워드
final은 *변경 불가(최종)* 를 의미하며, 클래스/변수/메서드에 적용 가능
## final 클래스
- 상속 불가 → 하위 클래스를 만들 수 없다.
## final 변수
- 한 번 초기화되면 값 변경 불가
- 초기화 위치
	- 정적 변수: 선언 시 or static 블록
	- 인스턴스 변수: 선언 시 or 생성자
	- 지역 변수: 선언 시 or 최초 한 번
## final 메서드
- 오버라이딩 불가
## instanceof 연산자
- 객체가 특정 클래스의 인스턴스인지 확인 (true / false 반환)
- 상속 관계뿐 아니라 **인터페이스 구현 여부**도 확인 가능
> _LSP(리스코프 치환 원칙)를 위반한 코드에서 자주 나타남 → 리팩터링 고려 필요

## package 키워드
- **네임스페이스(이름 공간)** 생성
- 서로 다른 패키지 안에서는 동일한 클래스명 사용 가능 → **클래스명 충돌 방지**
## interface 키워드와 implements 키워드
- 인터페이스는 오직 **public 추상 메서드**와 **public static final 상수**만 가질 수 있음
- 명시하지 않아도 자바가 자동으로 public, abstract, static, final 키워드 적용
## this 키워드
- **자기 자신 객체**를 지칭
- 변수 이름이  경우, 객체 변수는 this.를 붙여 구분
- 정적 변수는 클래스명.을 붙여 접근
## super 키워드
- 바로 **상위 클래스의 인스턴스**를 지칭
- super.super처럼 다단계 접근은 불가능
## 예비 고수를 위한 한마디
- JVM은 **객체의 메서드를 메모리에 하나만 보관**하고, 호출 시 this 객체 참조를 넘김
- 동일한 메서드를 객체마다 복사하지 않음 → 메모리 절약을 위한 최적화