## 1장 사람을 사랑한 기술

이 책의 저자는 스프링을 학습하기 이전에 기계어와 어셈블리어를 이해하고 공부하길 권한다. 따라서 기계어와 어셈블리어 이야기에 대해서 정리해보았다.

기계어
---

기계어는 0과 1밖에 없다. 컴퓨터는 이것들 밖에 이해하지 못한다. 

```
01010101000000100001001
```
위는 0과 1로 이뤄진 2진 수열이다. 1과 3을 더하는 기계어이다.


```
01010101 00000001 00001001
```
위는 8자리씩 끊은 모습이다. 우리가 조금 눈에 들어오기 좋을려면 끊어서 두는게 좋은것 같다.

```
11011100 00011000 10011000
```
위는 1+3 연산이다.

어셈블리어
---

일상 용어로 표현하고 이걸 기계어로 번역하는 언어

CPU 마다 언어가 달랐다. 그래서 코드표를 들고 다녀야했다. 어셈블리어를 기계어로 번역해 주는 소프트웨어를 어셈블러(Assembler)라고 한다.

01010101 을 ADD 라는 문자로 대신한 것이다.

---
중간에 많은 언어들이 있었지만, 해당 책은 C언어로 건너뛰게 되었다.

C언어
---

```
a = 1+3;
```
위 소스파일을 C 컴파일러로 컴파일만 하면 각 기계에 맞는 기계어 파일이 만들어지고 프로그램이 돌아가게 된다.

---

## 2장 자바와 절차적/구조적 프로그래밍

### 자바 프로그램 개발과 구동 도구

<table>
<tr>
<td>이름</td>
<td>설명</td>
</tr>

<tr>
<td>JDK(Java Development Kit) </td>
<td>자바 개발 도구 </td>
</tr>

<tr>
  <td>JRE(Java Runtime Environment)</td>
<td>자바 실행 환경</td>
</tr>

<tr>
<td>JVM(Java Virtual Machine)</td>
<td>자바 가상 기계</td>
</tr>
</table>

<table>

### T 메모리 구조

<tr>
<td>실행영역</td>
<td>역할</td>
</tr>

<tr>
<td>스태틱(static) 영역 </td>
<td>클래스의 놀이터 </td>
</tr>

<tr>
  <td>스택(stack) 영역</td>
<td>메서드의 놀이터</td>
</tr>

<tr>
<td>힙(Heap) 영역</td>
<td>객체의 놀이터</td>
</tr>
</table>

### 다시 보는 main() 메서드 : 메서드 스택 프레임

```
public class Start{
  public static void main(String[] args){
    System.out.println("Hello OOP!!!");
  }
}
```

위 코드를 실행하면 T 메모리는 어떤 상태일까?

#### main() 메서드가 실행되기 전 JVM에서 수행하는 전처리 작업들

- java.lang 패키지를 T메모리의 스태틱 영역에 배치한다.
- import된 패키지를 T 메모리의 스태틱 영역에 배치한다.
- 프로그램 상의 모든 클래스를 T 메모리의 스태틱 영역에 배치한다.

중괄호(블록)을 기점으로 스택 메서드 프레임이 생성되고 제거된다. 중괄호 내의 일어난 일들은 스택 메서드 프레임이 삭제되면서 해당 프레임 내부의 변수 프레임들도 같이 삭제가 된다.

### 지역 변수와 전역 변수

전역 변수는 코드 어느 곳에서나 접근할 수 있다고 해서 전역 변수라고 하며, 여러 메서드들이 공유해서 사용한다고 해서 공유 변수라고도 한다. 그런데 전역 변수를 쓰지 말라고들 하는데 왜 그럴까 생각해보자. 프로젝트 규모에 따라 코드가 커지면서 여러 메서드에서 전역 변수의 값을 변경하기 시작하면 T 메모리로 추적하지 않는 이상 전역 변수에 저장돼 있는 값을 파악하기 쉽지 않기 떄문이다. 방금 전 살펴본 코드에서도 main() 메서드에서는 share 변수에 55를 저장했으니 그 값이 55라고 착각할 수 있다.

읽기 전용으로 값을 공유해서 전역 상수로 쓰는 것을 적극 추천.

### 멀티쓰레드/ 멀티프로세스

멀티프로세스는 하나의 프로세스가 다른 프로세스의 T 메모리 영역을 절대 침범할 수 없는 메모리 안전한 구조이지만 메모리 사용량은 그만큼 크다.

멀티스테드는 하나의 T 메모리 안에서 스택 영역만 분할한 것이기 때문에 하나의 스레드에서 다른 스레드의 스택 영역에는 접근할 수 없지만 스태틱 영역과 힙 영역은 공유해서 사용하는 구조다. 따라서 멀티 프로세스 대비 메모리를 적게 사용할 수 있는 구조다.

따라서 요청당 스레드(Servlet)가 요청당 프로세스(CGI)보다 더 효율적이다.

#### 나중에 좀더 깊게 공부해보면 좋을것

쓰기 가능한 전역 변수를 사용하게 되면 스레드 안전성이 깨진다고 표현한다. 물론 이를 보완하느 방법으로 락(lock)을 거는 방법이 있지만, 멀티 스레드의 장점을 버린것 과 같다.

내생각 : 전역변수를 서로 공유하여 사용될 가능성이 있기 때문이라고 생각한다. 스레드 동작에 대한 락을 걸어버리면 공유 자원으로써의 장점을 잃어 속도는 오히려 느려지고, 메모리 사용량도 늘어갈 거다.

또한, 쓰기 가능한 전역 변수로 사용하게 되면 처음에 할당되었던 변수 영역 프레임의 크기가 데이터가 새로 갱신되거나 추가될때마다 새로 할당이 이루어지고 따라서 공유의 역할을 잃어버리고 새로 메모리를 할당받을 가능성이 있다.

### 필드 vs 속성 함수 vs 메서드

객체지향에서 필드는 객체 변수 또는 정적 변수를 말하고, 속성은 필드를 외부에 노출시키는 메서드라고 하는 사람도 있다. 이 구분을 따르면 자바에서라면 get/set 메서드가 속성이라고 할 수 있다.

