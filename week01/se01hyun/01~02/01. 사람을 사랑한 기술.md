- 스프링 이전 기술들 - SOA, CBD, OOP, 절차적/구조적 프로그래밍, 기계어 or 어셈블리어 etc

> 💡 메타포(metaphor): 비유법의 한 종류 'A는 B다.'
> 💡 애드삭(EDSAC): 모리스 윌키스 제작 2진법을 적용한 세계 최초의 프로그램 내장 방식 전자 계산기
> 💡 유니박(UNIVAC): 최초의 상업용 컴퓨터
## 기계어에서 객체 지향 프로그래밍 언어로
- [f] " 기계어의 명령어들을 일상 용어로 표현하고, 이걸 기계가 알 수 있는 기계어로 번역하게 하면 어떨까? "
### 기계어 - 0과 1의 행진 / 너무나 비인간적인 언어
기계어는 기계가 이해하는 유일한 언어로, 2진 숫자인 0과 1로만 표현된다. 기계어 코드가 CPU에 따라 다르므로 이기종 간에 호환이 불가능하다.
### 어셈블리어 - 0과 1의 행진을 벗어나 인간 지향으로 / 기계어 니모닉
> 💡 니모닉(Mnemonic): 어떤 것을 기억하는 데 쉽게 하도록 도움을 주는 것. 니모닉은 재사용이 필요할 때 사람의 기억을 돕기 위해 명확하게 선택된 상징이나 상징의 조합을 사용하는 것을 말한다.
> 💡 어셈블러(Assembler): 어셈블리어를 기계어로 번역해 주는 소프트웨어
> 💡 어셈블리(Assembly): 니모닉(Mnemonic)과 기계어의 일대일 매칭 코드표

But, CPU마다 기계어가 달라 CPU별로 각자의 어셈블리어(Assembly Language)도 달랐다.
→ CPU마다 실행할 수 있는 기계어 세트가 달랐으니 당연히 어셈블리어도 기계어에 따라 달랐던 것!
ex) "더하기를 의미하는 기계어 01010101"에 매칭되는 어셈블리어 니모닉은 ADD라고 하자."
### C 언어 - 강력한 이식성 / #### One Source Multi Object Use Anywhere
기존: _멀티 소스_ - 어셈블리어라면 같은 일을 하는 프로그램의 소스 파일을 각 기계의 종류만큼 만들어야 했다.
C언어의 등장: _싱글 소스_ - 소스 파일을 단 하나만 만들면 된다. 하나의 소스 파일을 각 기계에 맞는 컴파일러로 컴파일만 하면 각 기계에 맞는 기계어 목적 파일이 만들어지는 것.

|             |          |                   |                      |
| ----------- | -------- | ----------------- | -------------------- |
|             | 기계어      | 어셈블리어             | C 언어                 |
| 개발자의 코딩     | 0과 1의 나열 | **일상 단어 사용**      | **수학적 기호 사용**        |
| 소스 파일       | 기종마다 하나씩 | 기종마다 하나씩          | **기종이 몇 개든 단 하나**    |
| 목적 파일 (기계어) | 소스 그 자체  | 어셈블러로 소스를 번역해 생성  | 컴파일러로 소스를 번역해 생성     |
| 기계어 비교      |          | 기계어와 1:1 대응하는 니모닉 | 기계어와 m:n 대응하는 수학적 기호 |

- One Source: 하나의 C 소스 파일만 작성
- Multi Object: 기종마다 하나씩 기계어 목적 파일을 생성
- Use Anywhere: 모든 컴퓨터에서 실행 가능

- [n] 이러한 삼단 논법을 적용하면 '하나의 소스로 모든 컴퓨터에서 실행 가능하다!'
하나의 소스를 가지고 기종별로 컴파일만 하면 해당 기종별로 목적 파일, 즉 기계어 코드가 만들어지는 것

> 인간이 이해하기 쉬운 언어 체계가 1:1 매칭이 아닌 m:n 매칭이 가능해졌다.
### C++ 언어 -  정말 인간적인 프로그래밍 방법론, 객체 지향

- [f] **C에 객체 지향 개념을 도입하여 탄생된 언어**
### 자바 - 진정한 객체 지향 언어
- C++: 객체 지향 개념을 도입해 만든 언어이지만, 객체 없는 프로그래밍도 가능하다. 즉, 객체 지향 지원 언어라고 할 수 있다.
- Java: 가상 머신(Virtual Machine) JVM 존재
	- One Source Multi Object Use Anywhere → Write Once Use Anywhere
	  C 언어 대비 글자수가 많이 줄었다.
	- 객체 지향 언어의 중심에는 클래스(class)가 있다. 자바에서는 클래스를 떠나 존재할 수 있는 것은 없다. 프로그램의 시작점인 main() 메서드마저도 클래스 외부가 아닌 내부에 존재해야 하며, 모든 메서드도 클래스.메서드명() 또는 객체.메서드명()으로 접근해야만 한다.
- C#: 가상 머신과 비슷한 공통 언어 런타임 CLR(Common Language Runtime)

|       | C            | 자바                            |
| ----- | ------------ | ----------------------------- |
| 소스 파일 | One source   | Write Once (One Source와 같은 말) |
| 목적 파일 | Multi Object | One Object                    |
| 실행    | Use Anywhere | Use Anywhere                  |
- [n] C 언어와 달리 자바는 컴파일러를 기종별로 따로 구매해두지 않아도 된다는 것이다.
- C 언어로 작성한 소스를 다른 기종의 컴퓨터에서 실행하려면 소스와 각 기종용 컴파일러를 준비해야만 했다. 하지만 자바로 구현한 소스는 다른 기종의 컴퓨터에서 실행하기 위해 목적 파일인 오브젝트 파일만 가져가면 된다. 물론 다른 기종의 컴퓨터에 해당 기종용 JRE가 설치돼 있어야 한다.

> 💡 JVM(Java Virtual Machine): 자바 가상 머신 - 운영체제와 하드웨어 환경에 맞춰 자바 프로그램을 실행시켜주는 프로그램
> 💡JRE(Java Runtime Environment): 자바 런타임 환경 - 자바 프로그램을 실행하기 위한 JVM과 표준 라브러리가 포함된 환경
> 💡JDK(Java Development Kit): 자바 개발 키트 - 자바 프로그램을 개발하기 위해 필요한 도구 모음

|         |                   |                       |                                                    |
| ------- | ----------------- | --------------------- | -------------------------------------------------- |
|         | 어셈블리어             | C                     | 자바                                                 |
| 개발자의 코딩 | 일상 단어 사용          | 수학적 기호 사용             | 수학적 기호 사용                                          |
| 소스 파일   | 기종마다 하나씩          | 기종이 몇 개든 단 하나         | 기종이 몇 개든 단 하나                                      |
| 목적 파일   | 어셈빌러로 기계어 생성      | 컴파일러로 해당 운영체제용 기계어 생성 | 기종이 몇 개든 단 하나의 JVM용 기계어 생성                         |
| 기계어 비교  | 기계어랑 1:1 대응하는 니모닉 | 기계어와 m:n 대응하는 수학적 기호  | 기계어와 m:n 대응하는 수학적 기호                               |
| 비고      | 기종별 어셈블러 필요       | 기종별 컴파일러 필요           | 단 하나의 컴파일러만 필요<br>**기종별 JRE 세팅 필요(한 번만 설치해 주면 됨)** |

| 언어 발전사       | 개발자 사랑                                                                                                                                                                      |
| ------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 기계어          | - 개발자를 사랑하기에는 너무 초창기 기술<br>- 탄도의 궤적은 계산해 주었다                                                                                                                                |
| 어셈블리어        | - 인간의 언어로 프로그램 작성 가능                                                                                                                                                        |
| C            | - 하나의 소스로 이기종 간에 이식성 확보                                                                                                                                                     |
| C++          | - 객체 지향 개념 도입<br>- 인간적인 사고의 프로그래밍 방식                                                                                                                                        |
| 자바           | - 한 번의 컴파일로 이기종 간에 이식성 확보<br>- 포인터에 대한 개념 없이 프로그래밍 가능                                                                                                                       |
| 스프링<br>프레임워크 | - 거대함 속의 단순함과 완벽함, 그리고 유연함<br>- 아주 작고 작은 끈이 이 우주의 모든 물질을 구성하며, 그 성질 또한 지배한다는 끈 이론처럼 스프링은 IoC/DI, AOP, PSA라고 하는 객체 지향의 베스트 프랙티스만으로 아무리 거대한 프로그래밍이라도 쉽게 구현할 수 있음을 보여준 프레임워크다. |
#### UML을 대하는 자세
> 💡 통합 모델링 언어(UML: Unified Modeling Language): 소프트웨어 시스템의 구조, 동작, 상호작용을 시각적으로 표현하는 표준화된 범용 모델링 언어이다. 이 표준은 UML을 고안한 객체 관리 그룹에서 관리하고 있다.

- UML은 의사소통의 도구이며, 표기 방법론일 뿐이다. 의사소통의 목적을 위해서라면 UML을 비틀어서 사용해도 좋다. UML 표기법 하나하나에 애쓰지 않아도 된다.
#### CBD(Component Based Development)
*컴포넌트 기반 개발*
- 애플리케이션을 통째로 개발하는 것이 아닌, 애플리케이션을 의미 있는 단위로 구분하고 그 단위를 하나하나씩 부품으로 개발해 마치 레고 블록을 쌓아 올리듯 부품을 결합해 소프트웨어 제품을 완성하자는 방법론이자 기법이다. 제품이 아니다.
#### SOA(Service Oriented Architecture)
*서비스 중심 구조 또는 서비스 지향 구조*
- 개발자 입장에서의 개발이 아니라 실제 현실의 업무를 기준으로 개발하자는 사상이다.
#### 객체 지향의 4대 특성
- 객체 지향은 오랜 시간 정립된 개념으로 객체 지향 4대 특성, 객체 지향 설계 5원칙, 객체 지향의 베스트 프랙티스 모음인 디자인 패턴 등의 개념이 정립됐다. 자바나 C#과 같은 객체 지향 언어를 올바르게 사용하려면, 최소한 객체 지향 4대 특성을 제대로 이해해야 한다. 이를 바탕으로 올바른 객체 지향 사상을 담아낸 객체 지향 프로그램을 만들어낼 수 있기 때문이다.
#### 스프링 프레임워크는 사상이면서 또 단일 제품이다
객체 지향을 모르고 스프링을 안다는 것은 어불성설. 스프링은 객체 지향의 기반 위에 굳건히 서 있기 때문이다.
[표 1-7] 개념과 제품
[표 1-7 개념과 제품 2]
CBD나 SOA가 어려운 이우이다. 개념은 있으되 그것을 대표하는 제품이 없거나 사용해본 제품이 없으니 뜬구름인 것이다. 제품이 없다면 그 제품을 설명해 줄 메타포라도 있어야 이해하기 쉬운 법이다.

스프링 프레임워크가 제품이라면 분명 좀 쉬워야 하는데 왜 어렵다고들 할까? 첫 번재는 스프링 프레임워크가 무엇인지 그 개념을 명확히 알지 못하기 때문이고, 두 번째는 제품이 너무 방대하기 때문이다. 스프링 프레임워큰느 정말 방대하다. 필자가 생각하는 스프링 프레임워크의 개념은 OOP 프레임워크다. 스프링 프레임워크를 이해하려면 먼저 OOP를 알아야 한다. 더불어 프레임워크가 무엇인지 알아야 한다. 
스프링 프레임워크를 학습하기 가장 힘든 이유는 OOP 자체를 잘 모르거나 오해하고 있기 때문이다. 
흥미로운 사실이 하나 있다. 스프링 프레임워크는 규모의 방대함에도 불구하고 자기 철학을 통해 일관성 있는 방식으로 그 방대함을 쌓아 올렸다는 것이다. 끈 이론을 예로 든다면, 세상 모든 만물이 아주 작은 끈으로 구성돼 있다고 한다. 그 끈들이 진동하면서 모든 사물의 고유한 성질을 만들게 되고 우주의 법칙까지도 지배한다고 한다. 스프링 프레임워크에도 끈이론의 끈처럼 스프링을 지배하는 근원적인 요소가 바로 스프링 삼각형이라고 하는 IoC/DI, AOP, PSA이다. 스프링 삼각형은 POJO(Plain Old Java Object)에 세 가지 유형의 진동을 줌으로써 거대한 프레임워크를 완성해냈다.
#### 책 출간의 변
OOP 개념을 구현한 대표적인 제품 중 자바를 이해하기 위해 알아야 할 것
- OOP 개념
- 자바 언어의 문법
- 자바가 OOP 개념을 구현한 방식