## 자바 프로그램의 개발과 구동

| 현실 세계          | 가상 세계(자바 월드)   |                  |
| -------------- | -------------- | ---------------- |
| 소프트웨어 개발 도구    | JDK - 자바 개발 도구 | JVM용 소프트웨어 개발 도구 |
| 운영체제           | JRE - 자바 실행 환경 | JVM용 OS          |
| 하드웨어 - 물리적 컴퓨터 | JVM - 자바 가상 기계 | 가상의 컴퓨터          |
> 💡 JVM(Java Virtual Machine): 자바 가상 머신 - 자바로 개발한 프로그램을 실행시키기 위한 가상 컴퓨터

- 자바는 OS에 종속적이지 않다는 특징을 가지고 있지만, OS에 종속받지 않고 실행되기 위해서는 OS 위에 자바를 실행시킬 무언가가 필요한데, 바로 JVM이다. 즉, OS에 종속받지 않고 CPU가 자바를 인식, 실행할 수 있게 하는 가상 컴퓨터이다.
- Write Once Run Anywhere
	- JDK는 자바 소스 컴파일러인 javac.exe를 포함하고 있고, JRE는 자바 프로그램 실행기인 java.exe를 포함하고 있다. 자바가 이런 구조를 택한 이유는 기존 언어로 작성한 프로그램은 각 플랫폼(하드웨어와 OS의 조합)용으로 배포되는 설치 파일을 따로 준비해야 했던 불편함을 없애기 위해서이다.
	- 자바 개발자는 본인이 사용 중인 플랫폼에 설치된 JVM용으로 프로그램을 작성하고 배포하면 각 플랫폼에 맞는 JVM이 중재자로서 각 플랫폼에서 프로그램을 구동하는 데 아무 문제가 없게끔 만들어주는 것!
- **자바 개발 도구인 JDK를 이용해 개발된 프로그램은 JRE에 의해 가상의 컴퓨터인 JVM 상에서 구동된다.**
	- 다만 배포되는 JDK, JRE, JVM은 편의를 위해 JDK가 JRE를 포함하고 다시 JRE는 JVM을 포함하는형태로 배포된다.
### 프로그램이 메모리를 사용하는 방식

| 코드 실행 영역 | 데이터 저장 영역 |
| -------- | --------- |
하나의 프로그램이 실행될 때 프로그램이 메모리를 사용하는 방식을 간략하게 표현한 표이다. 기계어를 포함한 모든 프로그래밍 언어의 공통된 메모리 사용 방식이다.
### 객체 지향 프로그램의 메모리 사용 방식

| 코드 실행 영역 | 스태틱(Static 영역) |            |
| -------- | -------------- | ---------- |
|          | 스택(Stack 영역)   | 힙(Heap) 영역 |

객체 지향 프로그램에서는 데이터 저장 영역을 다시 세 개의 영역으로 분할해서 사용한다.
### 자바에 존재하는 절차적/구조적 프로그래밍의 유산
객체 지향 언어를 이해하는 데 절차적/구조적 프로그래밍을 아는 것은 큰 도움이 된다.

절차적 프로그래밍을 한 마디로 표현하자면 goto를 쓰지 말라는 것이다. 자바는 goto를 예약어로 등록해놓기까지 했는데, 이는 사용하기 위함이 아니라 사용하지 못하게끔 선점을 해놓은 것이다. 자바 공식 문서에서 goto가 not used임을 확인할 수 있다. 

> const도 not used로 되어 있다는 것을 기억하자. 다른 언어의 const 역할을 자바에서는 final이 대신하고 있기 때문이다.

goto를 사용하게 되면 프로그램의 실행 순서가 인간이 이해하기에 너무 복잡해질 가능성이 있기 때문이다. goto를 사용하게 되면 프로그램의 실행 순서를 이리저리 이동할 수 있게 되는데, 그러한 이동이 잦아지면 소스를 이리저리 따라가면서 프로그램을 이해해야 하는 작업이 꽤 복잡하다. goto를 이용한 이동은 프로그램을 논리적으로 잘 구성하면 모두 피할 수 있는 것들이다. 그래서 자바에서는 원천적으로 goto의 사용을 금지하는 것이다.

구조적 프로그래밍은 함수를 쓰라는 것이다. 함수를 쓰면 좋은 이유는 우선 중복 코드를 한 곳에 모아서 관리할 수 있고, 논리를 함수 단위로 분리해서 이해하기 쉬운 코드를 작성할 수 있기 때문이다/ 여기에 더해 구조적 프로그래밍의 지침 중에는 공유 사용 시 문제가 발생하기 쉬운 전역 변수보다는 지역 변수를 쓰라는 것도 있다. 

그럼 자바 언어에서 이러한 절차적/구조적 프로그래밍의 유산은 어디에 남아 있을까? goto문은 제어 흐름을 이리저리 이동시키는 용도이고, 함수는 중복 코드 제거와 논리를 분할하기 위한 용도이다. 제어하면 생각나는 것은 순서도와 제어문이다. 함수는 객체 지향 언어에서라면 메서드와 같은 것이다. 결론적으로 객체 지향 언어에서 절차적/구조적 프로그래밍의 유산은 메서드 안에서 확인할 수 있다. 객체 지향 프로그래밍에서 제어문이 존재할 수 있는 유일한 공간이 바로 메서드 내부이기 때문이다.

> 💡 함수(Function)와 메서드(Method)는 무엇이 다를까?
> 전혀 다르지 않다. 절차적/구조적 프로그래밍에서 함수라 불렀으니 객체 지향에서는 좀 다르게 불러야 하않을까 해서 메서드라고 불렀다고 한다. 굳이 차이점을 찾는다면 함수는 클래스나 객체와 아무 관계가 없지만 메서드는 반드시 클래스 정의 안에 존재해야 한다는 것이다. 객체 지향 언어에서 클래스 외부에 존재할 수 있는 것은 없다.
### main() 메서드: 메서드 스택 프레임
main() 메서드는 프로그램이 실행되는 시작점이다. main() 메서드가 실행될 때 메모리, 특히 T 메모리(데이터 저장 영역에 해당하는 static, stack, heap 영역을 T 메모리라고 부른다.)에는 어떤 일이 일어날까? 
``` java
public class Start {
	public static void main(String[] args) {
		System.out.println("Hello OOP!")
	}
}
```

| 스태틱 영역 - 클래스의 놀이터 |                 |     |
| ----------------- | --------------- | --- |
| 스택 영역 - 메서드들의 놀이터 | 힙 영역 - 객체들의 놀이터 |     |
1. JRE는 먼저 프로그램 안에 main() 메서드가 있는지 확인한다.
2. main() 메서드의 존재가 확인되면 JRE는 프로그램 실행을 위한 사전 준비에 착수해 가상의 기계인 JVM에 전원을 넣어 부팅하는 것이다.
3. 부팅된 JVM은 목적 파일을 받아 그 목적 파일을 실행한다. JVM이 가장 먼저 하는 일은 전처리라고 하는 과정이다.
4. JVM은 가장 먼저 *java.lang*(모든 자바 프로그램이 반드시 포함하게 되는 패키지) 패키지를 T 메모리의 스태틱 영역에 가져다 놓는다.
	java.lang 패키지가 있기에 System.out.println() 같은 메서드를 쓸 수 있게 되는 것이다.
5. 다음으로 JVM은 개발자가 작성한 모든 클래스와 임포트 패키지 역시 스태틱 영역에 가져다 놓는다.
	main() 메서드가 실행되기 전 JVM에서 수행하는 전처리 작업들
	- java.lang 패키지를 T 메모리의 스태틱 영역에 배치
	- import된 패키지를 T 메모리의 스태틱 영역에 배치
	- 프로그램 상의 모든 클래스를 T 메모리의 스태틱 영역에 배치
6. main() 메서드의 스택 프레임이 스택 영역에 할당된다.
7. 메서드 인자(들)의 변수 공간을 할당한다.
8. 명령문 실행

- main() 메서드는 프로그램의 시작점이면서 끝이기도 하다. main() 메서드가 끝나면 JRE는 JVM을 종료하고 JRE 자체도 운영체제 상의 메모리에서 사라진다. 그럼 T 메모리도 이제 그 운명을 다하고 사라지게 되는 것이다.

- [f] 핵심 내용
- T 메모리 구조
- java.lang 패키지
- import 패키지와 클래스들
- 메서드 스택 프레임
- JVM
- JRE
### 변수와 메모리: 변수! 너 어디 있니?
```JAVA
public class Start 2 {
	public static void main(String[] args) {
	int i;
	i = 10;
	
	double d = 20.0;
	}
}
```
main() 메서드 스택 프레임 안에 밑에서부터 차곡차곡 변수 공간을 마련한다.
7번째 줄의 닫는 중괄호로 main() 메서드 스택 프레임이 스택 영역에서 사라진다. 즉, 프로그램이 종료된다.
### 블록 구문과 메모리: 블록 스택 프레임
``` java
public class Start3 {
	public static void main(String[] args) {
	int i = 10;
	int i = 20;
	
	if(i == 10) {
		int m - k + 5;
			k = m;
	} else {
		int p = k + 10;
			k = p;
		}

	// k = m + p;
	}
}
```
if ~ else 블록, 여는 중괄호를 만나면 스택 프레임이 시작되는데 여기서 만들어지는 스택 프레임은 메서드의 스택 프레임이 아니라 if문, 그것도 참인 블록의 스택 프레임이다. if 블록 중 참일 때의 블록을 종료하는 닫는 중괄호를 만나면 if 블록 스택 프레임은 스택 영역에서 사라진다. 이때 if 블록 스택 프레임 안에 상주하던 변수의 저장 공간도 함께 사라진다.
main() 메서드 스택 프레임을 소멸시키는 블록 마침 기호인 닫는 중괄호에서는 T 메모리 소멸, JVM 가동 중지, JRE가 사용했던 시스템 자원을 운영체제에 반납한다.
### 지역 변수와 메모리: 스택 프레임에 갇혔어요!
변수는 메모리에 있다? ⭕
변수는 T 메모리의 스태틱 영역, 스택 영역, 힙 영역 중 어디에? '**세 군데 모두**'

세 군데 각각에 있는 변수는 각기 다른 목적을 가진다. 각각의 이름도 지역 변수, 클래스 멤버 변수, 객체 멤버 변수로 다르다.
- 지역 변수는 스택 영역에서 일생을 보낸다. 그것도 스택 프레임 안에서 일생을 보내게 된다. 따라서 스택 프레임이 사라지면 함께 사라진다.
- 클래스 멤버 변수는 스태틱 영역에서 일생을 보낸다. 스태틱 영역에서 한번 자리 잡으면 JVM이 종료될 때까지 고정된(static) 상태로 그 자리를 지킨다.
- 객체 멤버 변수는 힙에서 일생을 보낸다. 객체 멤버 변수들은 객체와 함께 가비지 컬렉터라고 하는 힙 메모리 회수기에 의해 일생을 마치게 된다.
  
> *"외부 스택 프레임에서 내부 스택 프레임의 변수에 접근하는 것은 불가능하나 그 역은 가능하다."*
### 메서드 호출과 메모리: 메서드 스택 프레임 2
``` java
public class Start4{
	public static void main(String[] args) {
		int k = 5;
		int m;

		m = square(k);
	}

	private static int square(int k) {
		int result;

		k = 25;

		result = k;

		return result;
	}
}
```
메서드 호출이 일어나면 무조건 호출되는 메서드의 스택 프레임이 T 메모리 스택 영역에 새로 생성된다. square() 메서드 스택 프레임에는 반환값을 저장할 변수 공간이 맨 아래, 다음으로 인자를 저장할 변수 공간, 그리고 마지막으로 메서드의 지역 변수가 자리잡는다.

- [!] main() 메서드가 가진 변수 k와 square() 메서드가 가진 변수 k가 이름만 같지 실제로는 서로 별도의 변수 공간이다. → *Call By Value(값에 의한 호출)*
	- square() 메서드 안의 k 변수에 무슨 짓을 해도 main() 메서드 안의 k 변수는 영향이 없다.

Q. main() 메서드의 어디에선가 square() 메서드 내의 지역 변수 result에 직접 접근할 수 있을까? 역으로 square() 메서드의 어디에선가 main() 메서드의 지역 변수 m에 직접 접근할 수 있을까?
A. ❌ 절대 접근할 수 없다.
1. 그것이 이치에 맞기 때문이다. 메서드는 서로의 고유 공간인데, 서로 침범하면 무단 침입으로 자바 월드문제를 유발할 수 있기 때문이다.
2. 포인터 문제 때문이다. square() 메서드에서 main() 메서드 내부의 지역변수 m에 접근한다고 하면 m의 위치를 명확히 알아야 하는데, 그 위치를 명확히 알기 위해서는 바로 m 변수의 메모리 위치, 즉 포인터라고 읽고 메모리 주소 값이라 이해해야 하는 그 값을 알아야 한다.
3. 예제의 코드는 square() 메서드를 main() 메서드 혼자서 호출하는 코드지만 실전에서 사용되는 메서드는 다양한 곳으로부터 호출된다. 이때 호출하는 메서드 내부의 지역 변수를 호출당하는 쪽에서 제어할 수 있게 코드를 만들려면 결국 포인터를 주고받아야 한다.
### 전역 변수와 메모리: 전역 변수 쓰지 말라니까요!
``` java
public class Start5 {
  static int share;
  
  public static void main(String[] args) {
    share = 55;
    
    int k = fun(5, 7);
    
    System.out.println(share);
  }
  
  private static int fun(int m, int p) {
    share = m + p;
    
    return m - p;
  }
}
```
코드를 보면 share 변수에 static 키워드가 붙어있다. 그래서 share 변수는 T 메모리의 스태틱 영역에 변수 공간이 할당된다. 그것도 Start5 클래스 안에 정의됐으니 해당 클래스가 T 메모리 스태틱 영역에 배치될 때 그 안에 share 변수가 클래스의 멤버로 공간을 만들어 저장된다.

#### 지역 변수와 전역 변수
- 스택 프레임에 종속적인 지역 변수
- 스택 프레임에 독립적인 전역 변수

전역 변수는 코드 어느 곳에서나 접근할 수 있어 전역 변수라고 하며, 여러 메서드들이 공유해서 사용한다고 해서 공유 변수라고도 한다.

하지만 프로젝트 규모에 따라 코드가 복잡해지면서 여러 메서드에서 전역 변수의 값을 변경하기 시작하면 T 메모리로 추적하지 않는 이상 전역 변수에 저장돼 있는 값을 파악하기 쉽지 않다. 그러니 전역 변수는 피할 수 있다면 즐기지 말고 피해야 할 존재다. 다만 읽기 전용으로 값을 공유해서 전역 상수로 쓰는 것은 적극 추천한다. 가장 대표적인 전역 상수 후보로는 원주율을 나타내는 PI 값 등이 있다.
### 멀티 스레드 / 멀티 프로세스의 이해
멀티 스레드(Multi Thread)의 T 메모리 모델은 스택 영역을 스레드 개수만큼 분할해서 쓰는 것

멀티 프로세스는 다수의 데이터 저장 영역, 즉 다수의 T 메모리를 갖는 구조다.

멀티 프로세스는 각 프로세스마다 각자의 T 메모리가 있고 각자 고유의 공간이므로 서로 참조할 수 없다. 그에 반해 멀티 스레드는 하나의 T 메모리만 사용하는데 스택 영역만 분할해서 사용하는 구조다.
멀티 프로세스는 하나의 프로세스가 다른 프로세스의 T 메모리 영역을 절대 침범할 수 없는 메모리 안전한 구조이지만 메모리 사용량은 그만큼 크다.

멀티 스레드는 하나의 T 메모리 안에서 스택 영역만 분할한 것이기 때문에 하나의 스레드에서 다른 스레드의 스택 영역에는 접근할 수 없지만 스태틱 영역과 힙 영역은 공유해서 사용하는 구조다. 따라서 멀티 프로세스 대비 메모리를 적게 사용할 수 있는 구조다.


``` java
public class Start6 extends Thread {
    static int share;

    public static void main(String[] args) {
        Start6 t1 = new Start6();
        Start6 t2 = new Start6();

        t1.start();
        t2.start();
    }

    public void run() {
        for (int count = 0; count < 10; count++) {
            System.out.println(share++);

            try {sleep(10000);}
            catch (InterruptedException e) {}
        }
    }
}
```
### 정리 - 객체 지향은 절차적/구조적 프로그래밍의 어깨를 딛고
**메서드를 만들 때는 순서도 또는 의사 코드를 작성하는 것이 좋다.**

UML 액티비티 다이어그램을 그리는 것도 좋긴 하지만, 필자가 제일 좋아하는 메서드의 로직 설계 방법은 NS 다이어그램이다.

> NS 다이어그램의 정식 명칭: 나시 슈나이더만 다이어그램(NassiShneiderman diagram)

- [f] 핵심 내용
- 스태틱: 클래스의 놀이터
- 스택: 메서드의 놀이터
- 힙: 객체의 놀이터